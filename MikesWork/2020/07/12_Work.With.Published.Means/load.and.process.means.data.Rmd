# Analysis
## Plan
- Load standardized means
- Fit model using weights for counts inversely related to mean value 
	- Poisson Like: W = 1/(mean +1) since $E(X) = \lambda = \var(X)$
# Install packages
```{r}
if (!requireNamespace("readr", quietly = TRUE))
    install.packages("readr")

if (!requireNamespace("forcats", quietly = TRUE))
    install.packages("forcats")
## Distributions Hermite Polynomial Approximation: used to calculate moments for truncated distributions. using truncatedNormalMoment
## We actually have censored data, where values exist but their exact value is unknown beyond the fact they are less than some threshold, not truncated data, which ignores data outside of a range.
##if (!requireNamespace("hpa", quietly = TRUE))
##    install.packages("hpa")
if (!requireNamespace("EnvStats", quietly = TRUE))
    install.packages("EnvStats")


## eivreg
if (!requireNamespace("eivtools", quietly = TRUE))
    install.packages("eivtools")

if (!requireNamespace("Biostrings", quietly = TRUE))
    BiocManager::install("Biostrings", lib="/home/mikeg/R/x86_64-pc-linux-gnu-library/3.6")



```

# Load Libraries
```{r}
library(Biostrings) ## process first to avoid conflicts
library(tidyr)
library(tibble)
library(readr)
library(dplyr)
library(stringr)
library(forcats)
library(EnvStats)
```

# Load and Shape Data

## E-MTAB
### Load Data
```{r}
emtabFile <- "E-MTAB-2812-query-results.tpms.tsv"
flatData  <- readr::read_tsv(emtabFile, skip=4) %>%
    dplyr::rename(WBID = `Gene ID`, geneName=`Gene Name` ) ## WBID is the WormBaseID

## use pivot_longer command (not gather which is depricated)
tData <- flatData %>% pivot_longer(-c(WBID, geneName), names_to = "long_description", values_to = "count")

## Now separate entry in descriptor column into separate column entries and filter out tissue specific data
sData  <- separate(tData, long_description, into=c("sex", "tissue", "stage"), sep=", ") %>% filter(tissue=="organism") %>%
#    mutate_if(is.character,as.factor)  %>% # convert char columns to factors
    replace_na(list(count = 0)) # replace NAs with 0.
## Before doing so the min value in the tibble was 0.1

creationInfo <- paste0("\tDate: ", date(), "\n\tLocation: ", sub(".*/AcrossTissue", "AcrossTissue", getwd()))
comment(sData) <- paste0("Data from ", emtabFile, "in tidy format.\n", creationInfo) 
```

### Create stageCounts 
- Data includes a new set of measurements for sex='hermaphrodite' stage='embryo Ce'.
This data is created from the median values of all sex = 'hermaphrodite' and stage = '* embryo Ce' data
```{r}
## Get hermphrodite embryo stage names (male, 'embryo Ce' lacks a space at the start)
embryoStageNames  <- unique(sData$stage[grepl(' embryo Ce', sData$stage )])
embryoStageCounts  <-  filter(sData, stage %in% embryoStageNames) %>% group_by(WBID)

combinedEmbryoStageCounts <- unique(embryoStageCounts %>% summarise(geneName, sex, tissue, stage="embryo Ce", median=median(count)))

nonEmbryoStageCounts <- filter(sData, !(stage %in% embryoStageNames)) 

stageCounts <- bind_rows(combinedEmbryoStageCounts, nonEmbryoStageCounts)
## 
## Make things simple and focus on just the 'main' lifestage measurements
## note that the stage "embryo Ce" is specific to sex = male
## Thus need to combine embryo measurements some how
## Try using median of stages

```

### Create Counts for mainLifeStages 
```{r}
## This will include both sex = c('male', 'hermaphrodite')
mainLifeStages <- c("embryo Ce", "L1 larvae Ce", "L2 larvae Ce", "L3 larvae Ce", "L4 larvae Ce", "adult Ce", "dauer larvae Ce", "post dauer stage Ce")
comment(mainLifeStages)=paste0("List of main lifestages to use in regression.\n", creationInfo)

tidyFullLifeStageData <- filter(sData, (stage %in% mainLifeStages)) ## & sex == "hermaphrodite")) 
comment(tidyFullLifeStageData) <- c("RNASeq counts for each of the\n\t- hermaphrodite non-embryo lifestages: L1 larvae Ce, L2 larvae Ce, ... adult\n\t- male lifestages\n\t- median of the very specific 'hermphrodite,  *embryo Ce' which are 'hermphrodite, embryo Ce.\nAll data for tissue == organism.\nCounts from E-MTAB-2812-query-results.tpms.tsv.", creationInfo ) 


###
tidyFullLifeStageDataMoments <- tidyFullLifeStageData %>% group_by(stage)%>% summarize(stage_sd = sd(count), stage_logSd = sd(log(count, 10)) )


summary(tidyFullLifeStageData$count)
## hist(tidyFullLifeStageData$count)
hist(log(tidyFullLifeStageData$count))

## Export data using 'geneName' name or WormBaseID
WormBaseIDandGeneNameData <- unique(select(tidyFullLifeStageData, c(WBID, geneName)))
comment(WormBaseIDandGeneNameData) <- paste("Mapping between WormBase IDs and geneName in FASTA file")
tidyGeneNameLifeStageData <- select(tidyFullLifeStageData, -WBID)
tidyWBIDLifeStageData <- select(tidyFullLifeStageData, -geneName)

## Export values
## Don't use write_csv because that only works with dataframes,not tibbles
## write.csv converts the tibble to a dataframe
save(tidyFullLifeStageData, mainLifeStages, tidyGeneNameLifeStageData, tidyWBIDLifeStageData, file = "processed.E-MTAB.data.Rdata")
```
### Estimate SD of log(counts) from E-MTAB Data taking into account data censoring 
- The lowest count value is 0.1, thus treat all 0 counts (previous empty cells) as coming from a censored distribution at mRNA < 0.1 counts.
- An example of such an approach can be found [here](https://www.r-bloggers.com/fitting-censored-log-normal-data-2/).
- An alternative distribution is the 'Zero Modified Log-Normal' which assumes a mixture distribution which is a LogN with an additional probability mass at 0.
- Zero Modified Log-Normal (ZMLN)  is included in the [EnvStats](http://finzi.psych.upenn.edu/R/library/EnvStats/html/ZeroModifiedLognormal.html) package.
  - This package generates CI for the mean, but not the SD.
  Could bootstrap data to generate CI for the SD
- "One way to try to assess whether a zero-modified lognormal (delta), zero-modified normal, censored normal, or censored lognormal is the best model for the data is to construct both censored and detects-only probability plots (see qqPlotCensored)" - EnvStats page above

## ROC 

### Get gene names
#### Extract from FASTA file
- There are a bunch of anomolous genes that have a phi of 1 but an elevated sd relative to the rest of genes with that value
Turns out they have a width which is not a multiple of 3.
- Note that a gene may have some isoforms that are not multiples of 3, so we don't want to exclude all isoforms of a gene.
- Data that hasn't been filtered for these anomolous genes has the prefix 'unfiltered'.
- Filtered data does not have a prefix.
- ROC analyses should be rerun with these genes filtered out.

```{r}
## Load original FASTA file
## Using Biostrings function which is not a standard df
unfilteredSeqData <- readDNAStringSet("c_elegan.fasta")

## names are really long descriptions.
## NEed to extract relevant part
unfilteredSeqDesc  <- names(unfilteredSeqData)
unfilteredSeqLength <- width(unfilteredSeqData)
unfilteredSeqGeneNames <- sub(".*\\[gene=([^]]+).*", "\\1", unfilteredSeqDesc)
##seqGeneWidth<- width(seqData) %>% as_tibble()

## use geneName for descript
names(unfilteredSeqData) <- unfilteredSeqGeneNames

## verify there's a match for each entry
if(sum(is.na(unfilteredSeqGeneNames)) ==0) print("Every entry matches")

## Verify that all 'names' are unique.
if(length(unfilteredSeqGeneNames) != length(unique(unfilteredSeqGeneNames))) print("Some geneNames appear twice due to isoforms")


## Filter out whose length is not a multiple of 3
## Keep name of filtered data simple
unfilteredFastaInfo <- tibble(info=names(unfilteredSeqData), geneName=unfilteredSeqGeneNames, length=as.double(unfilteredSeqLength))

## Create a vector flagging isoforms with proper gene lengths
properLengthIsoformsFlag <- ((unfilteredFastaInfo$length %% 3) == 0)

## Check for MtDNA genes
## Results indicate there are none. Good!
## filter(unfilteredFastaInfo, grepl("MtDNA", info) )

seqData <- unfilteredSeqData[properLengthIsoformsFlag, ]
fastaInfo <- unfilteredFastaInfo[properLengthIsoformsFlag, ]

```




#### Import Phi Values from ROC Output
```{r}
## detailed information on phi: posterior mean, posterior mean of log10(phi), etc
## StdError really StdDev of posterior
unfilteredPhiPosteriorInfo <- readr::read_csv("phi.posterior.unlabeled.csv") %>% dplyr::rename(phi = PHI, logPhi = log10.PHI, sd = Std.Error, logSd = log10.Std.Error)

## Not yet filtered for genes that have anomolous lengths (i.e. length mod 3 !=0)
unfilteredPhiData  <- as_tibble(bind_cols(geneName=unfilteredSeqGeneNames, unfilteredPhiPosteriorInfo, length=unfilteredSeqLength))
write.csv(unfilteredPhiData, file="labeled.unfiltered.phi.data.csv")

# rm(unfilteredPhiPosteriorInfo)
## 
dim(unfilteredPhiData)
plot(unfilteredPhiData$phi, unfilteredPhiData$sd)
phiData <- unfilteredPhiData[properLengthIsoformsFlag, ]

## verify you've filtered correctly
plot(phiData$phi, phiData$sd)

anomolousLengthIsoformsFlag <- !properLengthIsoformsFlag
anomolousGeneInfo <- unfilteredFastaInfo[anomolousLengthIsoformsFlag, ]
anomolousPhiData  <-unfilteredPhiData[anomolousLengthIsoformsFlag, ]
plot(anomolousPhiData$phi, anomolousPhiData$sd, title="Isoforms Whose Lengths are Not Multiples of Three")
write.csv(anomolousGeneInfo, "./anomolousGeneInfo.csv")




## Problem: Isoforms of the same gene exist in the fasta file (and thus phi estimates), but are not part of the E-MTAB measurements which are indexed the gene, not isoform of a gene, level.
## Solution: Combine separate estimates using median values of phi

summaryStatsPhiData  <- phiData %>% group_by(geneName) %>% summarize(median_phi = median(phi), median_sd = median(sd), median_length = median(length), median_logPhi=median(logPhi), median_logSd=median(logSd),  n_isoforms = length(phi) )
comment(summaryStatsPhiData) <- "summary stats for means and sd of phi for a geneName's multiple isoforms which are summarized in n_isoforms"
dim(summaryStatsPhiData)

par(mfrow=c(2,2))
plot(summaryStatsPhiData$median_phi, summaryStatsPhiData$median_sd)
plot(summaryStatsPhiData$median_length, summaryStatsPhiData$median_sd, log="xy")
plot(summaryStatsPhiData$median_phi, summaryStatsPhiData$median_length, log="xy")
## Create histogram of short genes
tmp <- summaryStatsPhiData$median_length[ summaryStatsPhiData$median_length < 400]
hist(tmp, xlim=c(0, max(tmp)), main="Histogram of Gene Lengths < 400 aa", xlab="Length" )
dev.off()

## log metrics
par(mfrow=c(2,2))
plot(summaryStatsPhiData$median_logPhi, summaryStatsPhiData$median_logSd)
plot(summaryStatsPhiData$median_length, summaryStatsPhiData$median_logSd, log="x")
plot(summaryStatsPhiData$median_logPhi, summaryStatsPhiData$median_length, log="y")
## Create histogram of short genes
tmp <- summaryStatsPhiData$median_length[ summaryStatsPhiData$median_length < 400]
hist(tmp, xlim=c(0, max(tmp)), main="Histogram of Gene Lengths < 400 aa", xlab="Length" )
dev.off()


write.csv(summaryStatsPhiData, file="summaryStatsPhiData.csv")

save(phiData, summaryStatsPhiData, seqData, file = "processed.ROC.data.Rdata") 
```


#### Import Phi Values Using Lu's File -- BROKEN! NOT USED
- Don't use Lu's file
```{r eval=FALSE}

## NOTE: rocNames is corrupt.  It has replaced some gene names with date formats (e.g. apr-1 has been converted to 1-Apr
rocNamesBroken <- read_csv("phi.mean.by.names.csv", col_names = c("geneName","phi2") )
rocNamesBroken[rocNamesBroken$geneName=='1-Apr',]
## THere are 17 corrupted names
length(unfilteredSeqGeneNames) - sum(rocNamesBroken==unfilteredSeqGeneNames)

## Need to run 'Get estimates from ROC' code below to evaluate following line
phiBrokenDataCheck  <- bind_cols(rocNamesBroken, unfilteredPhiPosteriorInfo)
## Verify that phi values line up between the two datasets
plot(phiBrokenDataCheck$phi2, phiDataBrokenCheck$phi)
```


### Examine Anomolous Genes
- Originally observed as cluster of genes with phi~1 and elevated SDs
- Upon examination we see they are actually genes with n mod 3 !=0.
- Don't need to evaluate this code any more
```{r eval=FALSE}
length(anomolousGeneNames$geneName)
length(unique(anomolousGeneNames$geneName))
anomolousInfo <- filter(unfilteredFastaInfo, geneName %in% anomolousGeneNames$geneName)
regularInfo <- filter(unfilteredFastaInfo, !(geneName %in% anomolousGeneNames$geneName))

```

# Modeling error in RNA Seq Data
If the underlying distribution is 
	- poisson, then Var=Rate so W = 1/count or 1/(count + k)

## Combine empirical and ROC data
```{r}

## Rename phi columns and add 'stage'
tidyFilteredAndWeightedPhiData <- summaryStatsPhiData  %>%
    mutate(count=median_phi, weight=1/(sd_phi/mean(sd_phi))^2, stage="phi") %>%
    select(-c(n_isoforms, sd_phi, median_phi))


## Calculate weights for empirical data

## Combine phi
tidyFilteredAndWeightedLifeStageData <- tidyLifeStageData %>%
    filter(geneName %in% standardizedPhiData$geneName) %>%
    mutate(weight=(1/(count+1)) ) ## x+1 poisson weighting


tidyJoinedData <- bind_rows(tidyFilteredAndWeightedLifeStageData, tidyFilteredAndWeightedPhiData) %>%
    mutate_if(is.character, as.factor)

joinedData <- pivot_wider(tidyJoinedData, names_from=stage, values_from=c(count, weight)) 

```
## Fit Using *eivtools* 
```{r}
library(eivtools)

cData  <-bind_cols(phiData, 
eivreg(

```
